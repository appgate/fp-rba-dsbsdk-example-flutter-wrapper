part of modules;

enum _MalwareProtectorAPIConstants {
  guiNotification,
  toastNotification,
  toastMessageNotification,
  malwareGUIDrawableId,
  malwareGUITitle,
  malwareGUIMessage,
}

class MalwareProtectorAPI {
  MethodChannel channel;

  MalwareProtectorAPI(this.channel);

  Future startOverlappingProtection() {
    if (Platform.isIOS) return Future.error(SDKErrors.platformError);
    return channel.invokeListMethod(
        MethodNames.startOverlappingProtection.name, {}).then((response) {
      print("startOverlappingProtection $response");
      if ((response?.isNotEmpty ?? false) && response!.first is bool) {
        return Future.value(response.first);
      }
      return Future.value(false);
    }).catchError((error) => Future.error(AppgateSDKError.toError(error)));
  }

  Future<bool> configureOverlappingMalwareGUINotification(
      int drawableId, String title, String message) {
    if (Platform.isIOS) return Future.error(SDKErrors.platformError);
    return channel.invokeListMethod(
        MethodNames.configureOverlappingMalwareGUINotification.name, {
      _MalwareProtectorAPIConstants.malwareGUIDrawableId.name: drawableId,
      _MalwareProtectorAPIConstants.malwareGUITitle.name: title,
      _MalwareProtectorAPIConstants.malwareGUIMessage.name: message,
    }).then((response) {
      if ((response?.isNotEmpty ?? false) && response!.first is bool) {
        return Future.value(response.first);
      }
      return Future.value(false);
    });
  }

  void setOverlayListener(Function(OverlappingApp overlapingApp) listener) {
    if (Platform.isAndroid) {
      channel.setMethodCallHandler((call) async {
        debugPrint("setMethodCallHandler ${call.method}");
        if (call.method == MethodNames.setOverlayListener.name) {
          if (call.arguments is String) {
            Map<String, dynamic> jsonData = json.decode(call.arguments);
            listener(OverlappingApp.fromJson(jsonData));
          }
        }
      });
      channel.invokeMethod(MethodNames.setOverlayListener.name, {});
    }
  }

  Future setOverlayGUINotificationEnable(bool enable) {
    if (Platform.isIOS) return Future.error(SDKErrors.platformError);
    return channel.invokeListMethod(
        MethodNames.setOverlayGUINotificationEnable.name, {
      _MalwareProtectorAPIConstants.guiNotification.name: enable
    }).then((response) {
      if ((response?.isNotEmpty ?? false) && response!.first is bool) {
        return Future.value(response.first);
      }
      return Future.value(false);
    }).catchError((error) => Future.error(AppgateSDKError.toError(error)));
  }

  Future setOverlayToastNotificationEnable(bool enable) {
    if (Platform.isIOS) return Future.error(SDKErrors.platformError);
    return channel.invokeListMethod(
        MethodNames.setOverlayToastNotificationEnable.name, {
      _MalwareProtectorAPIConstants.toastNotification.name: enable
    }).then((response) {
      if ((response?.isNotEmpty ?? false) && response!.first is bool) {
        return Future.value(response.first);
      }
      return Future.value(false);
    }).catchError((error) => Future.error(AppgateSDKError.toError(error)));
  }

  Future configureOverlappingMalwareToastNotification(String message) {
    if (Platform.isIOS) return Future.error(SDKErrors.platformError);
    return channel.invokeListMethod(
        MethodNames.configureOverlappingMalwareToastNotification.name, {
      _MalwareProtectorAPIConstants.toastMessageNotification.name: message
    }).then((response) {
      if ((response?.isNotEmpty ?? false) && response!.first is bool) {
        return Future.value(response.first);
      }
      return Future.value(false);
    }).catchError((error) => Future.error(AppgateSDKError.toError(error)));
  }
}
